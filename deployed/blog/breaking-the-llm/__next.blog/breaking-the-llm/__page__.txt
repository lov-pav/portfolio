1:"$Sreact.fragment"
2:I[44298,["/_next/static/chunks/ea12239a14acbc1d.js","/_next/static/chunks/cd8fa2376cd44278.js","/_next/static/chunks/e077ac6148382a55.js","/_next/static/chunks/62397d08572e7e3e.js","/_next/static/chunks/12849b5b6ea987cc.js"],"default"]
3:I[2160,["/_next/static/chunks/ea12239a14acbc1d.js","/_next/static/chunks/cd8fa2376cd44278.js","/_next/static/chunks/e077ac6148382a55.js","/_next/static/chunks/62397d08572e7e3e.js","/_next/static/chunks/12849b5b6ea987cc.js"],"default"]
b:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
c:"$Sreact.suspense"
0:{"buildId":"c7blrjOImPQFhtbUh_M0B","rsc":["$","$1","c",{"children":[["$","$L2",null,{"title":"Implementing RSA from Scratch: A Cryptography Deep Dive","date":"April 7, 2025","category":"DevLog","children":[["$","p",null,{"children":["There's a difference between ",["$","em",null,{"children":"using"}]," encryption and ",["$","em",null,{"children":"understanding"}]," encryption. For my UTPB-COSC-4380 Cryptography class, I had to cross that gap—implementing Diffie-Hellman, RSA, and AES from scratch in Java."]}],["$","p",null,{"children":["The project files tell the story: ",["$","code",null,{"children":"DHE.java"}],", ",["$","code",null,{"children":"RSA.java"}],", ",["$","code",null,{"children":"AES.java"}],", and a ",["$","code",null,{"children":"primes.txt"}]," file I spent way too much time generating."]}],["$","h3",null,{"children":"Project 3: Diffie-Hellman Key Exchange"}],["$","p",null,{"children":"Diffie-Hellman is elegant. Two parties can establish a shared secret over an insecure channel without ever transmitting the secret itself. The math is simple but the implications are profound:"}],["$","pre",null,{"children":["$","code",null,{"children":"// DHE.java - The core exchange\n// Alice: g^a mod p -> sends to Bob\n// Bob: g^b mod p -> sends to Alice\n// Both compute: g^(ab) mod p = shared secret\n\npublic BigInteger computeSharedSecret(BigInteger otherPublic, \n                                       BigInteger myPrivate, \n                                       BigInteger p) {\n    return otherPublic.modPow(myPrivate, p);\n}"}]}],["$","p",null,{"children":["My implementation supports both ",["$","strong",null,{"children":"two-party"}]," and ",["$","strong",null,{"children":"three-party"}]," exchanges. The three-party version requires a circular exchange pattern where each party contributes to the final shared secret."]}],["$","h3",null,{"children":"RSA: More Than Encryption"}],["$","p",null,{"children":["Most people think of RSA as encryption, but ",["$","code",null,{"children":"RSA.java"}]," implements two separate operations:"]}],["$","ol",null,{"children":[["$","li",null,{"children":[["$","strong",null,{"children":"Encryption/Decryption:"}]," Hiding message content"]}],["$","li",null,{"children":[["$","strong",null,{"children":"Digital Signatures:"}]," Proving authenticity"]}]]}],["$","$L3",null,{"type":"llm"}],["$","pre",null,{"children":["$","code",null,{"children":"// RSA.java - Key Generation\nBigInteger p = generateLargePrime(1024);\nBigInteger q = generateLargePrime(1024);\nBigInteger n = p.multiply(q);\nBigInteger phi = (p.subtract(ONE)).multiply(q.subtract(ONE));\nBigInteger e = new BigInteger(\"65537\");  // Common public exponent\nBigInteger d = e.modInverse(phi);        // Private key\n\n// Encryption: c = m^e mod n\n// Decryption: m = c^d mod n"}]}],["$","p",null,{"children":["The hardest part wasn't the implementation—it was understanding ",["$","em",null,{"children":"why"}]," decryption works. It relies on Euler's theorem: m^(ed) ≡ m (mod n). I spent an entire weekend with a whiteboard proving it to myself."]}],["$","h3",null,{"children":"Project 4: AES in ECB and CBC Modes"}],["$","p",null,{"children":[["$","code",null,{"children":"AES.java"}]," was brutal. Unlike RSA's mathematical elegance, AES is a sequence of byte manipulations—SubBytes, ShiftRows, MixColumns, AddRoundKey, repeated 10 times."]}],["$","pre",null,{"children":["$","code",null,{"children":"// AES.java - CBC mode encryption\nbyte[] previousBlock = iv;\nfor (byte[] block : blocks) {\n    byte[] xored = xor(block, previousBlock);\n    byte[] encrypted = aesEncryptBlock(xored, key);\n    previousBlock = encrypted;\n    output.add(encrypted);\n}"}]}],["$","p",null,{"children":"The difference between ECB and CBC is crucial:"}],["$","ul",null,{"children":[["$","li",null,{"children":[["$","strong",null,{"children":"ECB:"}]," Each block encrypted independently. Fast but reveals patterns."]}],"$L4"]}],"$L5","$L6","$L7","$L8"]}],["$L9"],"$La"]}],"loading":null,"isPartial":false}
4:["$","li",null,{"children":[["$","strong",null,{"children":"CBC:"}]," Each block XORed with previous ciphertext. Hides patterns."]}]
5:["$","h3",null,{"children":"The Debug Output That Saved Me"}]
6:["$","p",null,{"children":["The smartest thing I did was add a debug flag that outputs state after each step. I kept an ",["$","code",null,{"children":"AES Debug.txt"}]," in the repo. When my output didn't match the reference, I could pinpoint exactly which step failed. The bug was always in MixColumns."]}]
7:["$","h3",null,{"children":"What I Learned"}]
8:["$","p",null,{"children":["Building cryptography from scratch teaches you to respect the math. Every line has to be ",["$","em",null,{"children":"exactly"}]," right—there's no \"close enough\" in security. But more importantly, I now understand why we never roll our own crypto in production."]}]
9:["$","script","script-0",{"src":"/_next/static/chunks/12849b5b6ea987cc.js","async":true}]
a:["$","$Lb",null,{"children":["$","$c",null,{"name":"Next.MetadataOutlet","children":"$@d"}]}]
d:null
